name: Generate Documentation

on:
  workflow_run:
    workflows: ["Update Configs"]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Generate Category Reports (Fixed Tables & Paths)
        run: |
          python3 << 'SCRIPT'
          import os
          import urllib.parse
          import yaml
          
          # 1. åŸºç¡€è®¾ç½®
          yaml.add_multi_constructor("!", lambda loader, suffix, node: None, Loader=yaml.SafeLoader)
          REPO_URL = "https://github.com/${{ github.repository }}/blob/main"
          
          # å®šä¹‰éœ€è¦æ‰«æçš„ç›®å½•
          CATEGORIES = {
              "THEYAMLS/Official_Examples": "Mihomo å®˜æ–¹ç¤ºä¾‹ (Official)",
              "THEYAMLS/General_Config": "é€šç”¨è¿›é˜¶é…ç½® (General Config)",
              "THEYAMLS/Smart_Mode": "Smart æ¨¡å¼ / è·¯ç”±ä¸“ç”¨ (Smart Mode)",
              "THEYAMLS/Mobile_Modules": "Android æ‰‹æœºæ¨¡å— (Mobile Modules)"
          }
          IGNORE_FILES = ["README.md", "LICENSE", "release_body.md"]

          def clean_table_cell(text):
              """æ¸…æ´—è¡¨æ ¼å†…å®¹ï¼Œé˜²æ­¢ Markdown é”™ä¹±"""
              if text is None: return "N/A"
              s = str(text)
              # è½¬ä¹‰ç«–çº¿ï¼Œé˜²æ­¢è¡¨æ ¼åˆ—æ–­è£‚ï¼›æ›¿æ¢æ¢è¡Œç¬¦
              return s.replace("|", "&#124;").replace("\n", "<br>").strip()

          def get_file_size(path):
              try:
                  size = os.path.getsize(path)
                  if size < 1024: return f"{size} B"
                  return f"{size/1024:.1f} KB"
              except: return "Unknown"

          def analyze_config(file_path):
              try:
                  with open(file_path, "r", encoding="utf-8") as f:
                      content = f.read()
                  
                  # å°è¯•è§£æ YAML
                  data = yaml.safe_load(content)
                  if not isinstance(data, dict): return None

                  info = {}
                  # æå–åŸºç¡€å­—æ®µ
                  info["mixed_port"] = data.get("mixed-port", "-")
                  info["ext_controller"] = data.get("external-controller", "-")
                  info["mode"] = data.get("mode", "rule")
                  info["ipv6"] = "âœ…" if str(data.get("ipv6", False)).lower() == "true" else "ğŸš«"
                  info["tun"] = "âœ…" if data.get("tun", {}).get("enable") else "ğŸš«"
                  
                  # ç»Ÿè®¡æ•°é‡
                  proxies = data.get("proxies", [])
                  providers = data.get("proxy-providers", {})
                  groups = data.get("proxy-groups", [])
                  rules = data.get("rules", [])
                  
                  info["proxy_count"] = len(proxies) if isinstance(proxies, list) else 0
                  info["provider_count"] = len(providers) if isinstance(providers, dict) else 0
                  info["group_count"] = len(groups) if isinstance(groups, list) else 0
                  info["rule_count"] = len(rules) if isinstance(rules, list) else 0

                  # æå–ç­–ç•¥ç»„è¯¦æƒ… (ç”¨äºå±•å¼€æ˜¾ç¤º)
                  group_details = []
                  if isinstance(groups, list):
                      for g in groups:
                          if isinstance(g, dict):
                              name = g.get("name", "Unknown")
                              g_type = g.get("type", "select")
                              group_details.append(f"| {clean_table_cell(name)} | `{g_type}` |")
                  info["group_details"] = group_details

                  return info
              except Exception as e:
                  print(f"Error analyzing {file_path}: {e}")
                  return None

          def generate_readme(folder, title):
              if not os.path.exists(folder):
                  return

              # æ”¶é›†æ–‡ä»¶
              files_data = []
              for root, _, files in os.walk(folder):
                  for f in files:
                      if f.endswith(('.yaml', '.yml')) and f not in IGNORE_FILES:
                          full_path = os.path.join(root, f)
                          # è®¡ç®—ç›¸å¯¹äº README çš„è·¯å¾„
                          rel_path = os.path.relpath(full_path, folder)
                          
                          analysis = analyze_config(full_path)
                          if analysis:
                              files_data.append({
                                  "filename": f,
                                  "rel_path": rel_path,
                                  "full_path": full_path,
                                  "size": get_file_size(full_path),
                                  "data": analysis
                              })

              if not files_data:
                  return

              # ç”Ÿæˆ Markdown å†…å®¹
              lines = []
              lines.append(f"# ğŸ“‚ {title}")
              lines.append("")
              lines.append("[ğŸ”™ è¿”å›ä¸»é¡µ](../../README.md)")
              lines.append("")
              lines.append(f"> ğŸ“Š å…±æ”¶å½• **{len(files_data)}** ä¸ªé…ç½®æ–‡ä»¶")
              lines.append("")

              # --- 1. æ¨ªå‘å¯¹æ¯”è¡¨æ ¼ (ä¸¥æ ¼å¯¹é½) ---
              lines.append("## âš”ï¸ å‚æ•°æ¨ªå‘å¯¹æ¯”")
              lines.append("")
              
              # è¡¨å¤´
              header = "| é…ç½®æ–‡ä»¶ | æ··åˆç«¯å£ | é¢æ¿ç«¯å£ | æ¨¡å¼ | TUN | ç­–ç•¥ç»„ | è§„åˆ™æ•° |"
              lines.append(header)
              lines.append("| :--- | :--- | :--- | :--- | :--- | :--- | :--- |")
              
              for item in files_data:
                  d = item["data"]
                  # æ„å»ºRawé“¾æ¥
                  raw_rel = os.path.relpath(item["full_path"], ".").replace(os.sep, "/")
                  raw_link = f"{REPO_URL}/{urllib.parse.quote(raw_rel)}"
                  
                  row = (
                      f"| [`{item['filename']}`]({raw_link}) "
                      f"| {clean_table_cell(d['mixed_port'])} "
                      f"| {clean_table_cell(d['ext_controller'])} "
                      f"| {d['mode']} "
                      f"| {d['tun']} "
                      f"| **{d['group_count']}** "
                      f"| {d['rule_count']} |"
                  )
                  lines.append(row)
              lines.append("")

              # --- 2. è¯¦ç»†åˆ†æ ---
              lines.append("## ğŸ“ è¯¦ç»†ç»“æ„åˆ†æ")
              
              # æŒ‰å­ç›®å½•(ä½œè€…)åˆ†ç»„
              files_data.sort(key=lambda x: x["rel_path"])
              
              current_subdir = ""
              for item in files_data:
                  subdir = os.path.dirname(item["rel_path"])
                  if subdir == "": subdir = "Root"
                  
                  if subdir != current_subdir:
                      lines.append(f"### ğŸ‘¤ {subdir}")
                      current_subdir = subdir
                  
                  d = item["data"]
                  lines.append(f"#### ğŸ“„ {item['filename']}")
                  lines.append(f"- **æ–‡ä»¶è·¯å¾„**: `{item['rel_path']}` ({item['size']})")
                  
                  if d["group_details"]:
                      lines.append("<details>")
                      lines.append(f"<summary>ğŸ” ç‚¹å‡»æŸ¥çœ‹ {len(d['group_details'])} ä¸ªç­–ç•¥ç»„è¯¦æƒ…</summary>")
                      lines.append("")
                      lines.append("| ç­–ç•¥ç»„åç§° | ç±»å‹ |")
                      lines.append("| :--- | :--- |")
                      lines.extend(d["group_details"][:20]) # é™åˆ¶æ˜¾ç¤ºå‰20ä¸ªï¼Œé˜²æ­¢è¿‡é•¿
                      if len(d["group_details"]) > 20:
                          lines.append(f"| ... | (å‰©ä½™ {len(d['group_details'])-20} ä¸ªéšè—) |")
                      lines.append("")
                      lines.append("</details>")
                      lines.append("")
                  
                  lines.append("---")

              # å†™å…¥æ–‡ä»¶
              out_path = os.path.join(folder, "README.md")
              with open(out_path, "w", encoding="utf-8") as f:
                  f.write("\n".join(lines))
              print(f"âœ… Generated: {out_path}")

          for path, title in CATEGORIES.items():
              generate_readme(path, title)
          SCRIPT

      - name: Update Root README (Safe Inject Mode)
        run: |
          python3 << 'SCRIPT'
          import os
          import re

          # === å…³é”®é…ç½® ===
          START_MARKER = ""
          END_MARKER = ""
          
          def get_file_content(path):
              if os.path.exists(path):
                  with open(path, "r", encoding="utf-8") as f:
                      return f.read()
              return ""

          # 1. æ‰«æè„šæœ¬è·å–åˆ—è¡¨ (å¤ç”¨åŸæœ‰é€»è¾‘)
          def parse_shell_script(script_path, category_name):
              if not os.path.exists(script_path): return []
              try:
                  content = open(script_path, encoding='utf-8', errors='ignore').read()
              except: return []
              
              results = []
              # åŒ¹é… (url)|(filename)
              pattern = r'(https?://[^|\s"\']+)\|([^"\n]+?\.ya?ml)'
              matches = re.findall(pattern, content)
              
              for url, output_path in matches:
                  filename = os.path.basename(url)
                  # ç®€å•æå–ä½œè€…
                  parts = url.split('/')
                  author = parts[3] if 'github.com' in url and len(parts)>3 else 'External'
                  
                  results.append({
                      "author": author,
                      "filename": filename,
                      "path": output_path.strip(), # THEYAMLS/Category/file.yaml
                      "url": url
                  })
              return results

          scripts = {
              "General": ".github/scripts/download-general.sh",
              "Smart": ".github/scripts/download-smart.sh",
              "Mobile": ".github/scripts/download-mobile.sh",
              "Official": ".github/scripts/download-official.sh"
          }
          
          data_map = {}
          for key, script in scripts.items():
              data_map[key] = parse_shell_script(script, key)

          # 2. æ„å»ºæ³¨å…¥å†…å®¹å— (Markdown)
          lines = []
          lines.append(START_MARKER)
          lines.append("## ğŸ“¦ è‡ªåŠ¨åŒæ­¥é…ç½®åˆ—è¡¨ (Auto-synced)")
          lines.append("> ğŸ”„ ä»¥ä¸‹å†…å®¹ç”± GitHub Actions è‡ªåŠ¨æ›´æ–°ï¼Œè¯·å‹¿æ‰‹åŠ¨ä¿®æ”¹æ­¤åŒºå—å†…å†…å®¹ã€‚")
          lines.append("")
          
          # ç›®å½•ç´¢å¼•
          lines.append("### ğŸ“‚ åˆ†ç±»å¯¼èˆª")
          lines.append("| åˆ†ç±» | æè¿° | è¯¦æƒ… |")
          lines.append("| :--- | :--- | :--- |")
          lines.append("| **é€šç”¨é…ç½®** | PC/Mac/æ‰‹æœºé€šç”¨ | [General Config](THEYAMLS/General_Config/README.md) |")
          lines.append("| **Smart æ¨¡å¼** | è·¯ç”±/è½¯è·¯ç”±ä¸“ç”¨ | [Smart Mode](THEYAMLS/Smart_Mode/README.md) |")
          lines.append("| **Android æ¨¡å—** | Root æ¨¡å—ä¸“ç”¨ | [Mobile Modules](THEYAMLS/Mobile_Modules/README.md) |")
          lines.append("| **å®˜æ–¹ç¤ºä¾‹** | åŸºç¡€çº¯å‡€é…ç½® | [Official Examples](THEYAMLS/Official_Examples/README.md) |")
          lines.append("")

          lines.append("### ğŸ“‹ æœ€æ–°æ”¶å½•")
          lines.append("| ğŸ‘¤ ä½œè€… | ğŸ“„ æ–‡ä»¶å | ğŸ”— åŸå§‹æ¥æº |")
          lines.append("| :--- | :--- | :--- |")

          # æ‰å¹³åŒ–å±•ç¤ºæ‰€æœ‰æ–‡ä»¶
          all_items = []
          for key in data_map:
              for item in data_map[key]:
                  item['category'] = key
                  all_items.append(item)
          
          # æŒ‰ä½œè€…æ’åº
          all_items.sort(key=lambda x: x['author'])

          for item in all_items:
              # æ„å»ºç›¸å¯¹é“¾æ¥: THEYAMLS/Category/file.yaml
              link_path = item['path']
              lines.append(f"| **{item['author']}** | [`{item['filename']}`]({link_path}) | [Source]({item['url']}) |")
          
          lines.append("")
          lines.append(END_MARKER)
          
          new_block = "\n".join(lines)

          # 3. å®‰å…¨å†™å…¥é€»è¾‘
          readme_path = "README.md"
          current_content = get_file_content(readme_path)
          
          if START_MARKER in current_content and END_MARKER in current_content:
              # æ›¿æ¢æ¨¡å¼ï¼šåªæ›´æ–°æ ‡è®°ä¸­é—´çš„å†…å®¹
              pattern = re.compile(f"{re.escape(START_MARKER)}.*?{re.escape(END_MARKER)}", re.DOTALL)
              final_content = pattern.sub(new_block, current_content)
              print("âœ… Detected markers. Updating content block only.")
          else:
              # è¿½åŠ æ¨¡å¼ï¼šå¦‚æœæ²¡æœ‰æ ‡è®°ï¼Œè¿½åŠ åˆ°æ–‡ä»¶æœ«å°¾ï¼ˆé˜²æ­¢è¦†ç›–å¤´éƒ¨ï¼‰
              # åªæœ‰å½“æ–‡ä»¶ä¸ºç©ºæ—¶ï¼Œæ‰æ·»åŠ æ ‡é¢˜ï¼Œå¦åˆ™åªè¿½åŠ åˆ—è¡¨
              if not current_content.strip():
                   header = "# ğŸ“¦ mihomo_yamls\n\nGenerated Config Collection.\n\n"
                   final_content = header + new_block
              else:
                   final_content = current_content + "\n\n" + new_block
              print("âš ï¸ No markers found. Appended to end of file.")

          with open(readme_path, "w", encoding="utf-8") as f:
              f.write(final_content)
          SCRIPT

      - name: Generate OpenClash Configs
        run: |
          python3 << 'SCRIPT'
          import os
          import yaml
          from urllib.parse import quote

          SOURCE_BASE = "THEYAMLS"
          OUTPUT_BASE = "Overwrite/THEOPENCLASH"
          REPO_RAW_BASE = f"https://raw.githubusercontent.com/${{ github.repository }}/main"
          
          yaml.add_multi_constructor("!", lambda loader, suffix, node: None, Loader=yaml.SafeLoader)

          # æ¸…ç†æ—§æ–‡ä»¶ (å¯é€‰ï¼Œé˜²æ­¢æ®‹ç•™)
          # if os.path.exists(OUTPUT_BASE): import shutil; shutil.rmtree(OUTPUT_BASE)

          for root, dirs, files in os.walk(SOURCE_BASE):
              for file in files:
                  if not file.endswith(('.yaml', '.yml')): continue
                  
                  full_path = os.path.join(root, file)
                  try:
                      # ç®€å•æ£€æŸ¥æ˜¯å¦æœ‰ providers
                      with open(full_path, 'r', encoding='utf-8') as f:
                          data = yaml.safe_load(f)
                      
                      providers = data.get('proxy-providers', {})
                      if not providers: continue
                      
                      # ç”Ÿæˆè·¯å¾„
                      rel_dir = os.path.relpath(root, SOURCE_BASE)
                      out_dir = os.path.join(OUTPUT_BASE, rel_dir)
                      os.makedirs(out_dir, exist_ok=True)
                      
                      # ç”Ÿæˆå†…å®¹
                      raw_url = f"{REPO_RAW_BASE}/{root}/{file}".replace("\\", "/") # ä¿®å¤ windows è·¯å¾„åˆ†éš”ç¬¦
                      raw_url = urllib.parse.quote(raw_url, safe=":/")
                      
                      conf_name = os.path.splitext(file)[0] + ".conf"
                      out_file = os.path.join(out_dir, conf_name)
                      
                      lines = [
                          f"# Source: {file}",
                          "[General]",
                          "DISABLE_UDP_QUIC = 1",
                          f"DOWNLOAD_FILE = url={raw_url}, path=/etc/openclash/config/{file}, cron=0 6 * * *, force=false",
                          f"CONFIG_FILE = /etc/openclash/config/{file}",
                          "SUB_INFO_URL = $EN_KEY1",
                          "",
                          "[Overwrite]"
                      ]
                      
                      idx = 1
                      for p_name in providers.keys():
                          lines.append(f'ruby_map_edit "$CONFIG_FILE" "[\'proxy-providers\']" "{p_name}" "[\'url\']" "$EN_KEY{idx}"')
                          idx += 1
                      
                      with open(out_file, 'w', encoding='utf-8') as f:
                          f.write("\n".join(lines))
                          
                  except Exception as e:
                      pass # è·³è¿‡é”™è¯¯æ–‡ä»¶
          SCRIPT

      - name: Commit and Push
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          git add .
          if git diff --staged --quiet; then
            echo "âœ… No changes detected."
            exit 0
          fi
          
          git commit -m "ğŸ¤– Auto: Generate docs & configs"
          git pull origin ${{ github.ref_name }} --rebase --autostash || true
          git push origin HEAD:${{ github.ref_name }}
